import hashlib
import hmac
import json
from fastapi import Request, HTTPException
import httpx 
from datetime import datetime 

from app.core.config import settings
from app.schemas.subscription_schema import Subscription
from app.models.user_model import Users

class IPaymuService:
    def __init__(self):
        self.va = settings.IPAYMU_VA
        self.api_key = settings.IPAYMU_API_KEY
        self.payment_url = "https://sandbox.ipaymu.com/api/v2/payment"

    def _create_signature(self, body: dict) -> str:
        """
        Creates a SHA256 signature for the request body as required by iPaymu.
        The signature is generated by:
        1. JSON serializing the request body using compact separators.
        2. Calculating the SHA256 hash of the serialized body.
        3. Constructing the string to sign: "POST:VA:RequestBodySHA256Hash:APIKey".
        4. Generating HMAC-SHA256 of the string to sign using APIKey as the secret.
        """
        # Use separators=(',', ':') for compact JSON serialization as per docs
        body_json = json.dumps(body, separators=(',', ':'))
        # 1. Calculate SHA256 hash of the body JSON
        body_sha256_hash = hashlib.sha256(body_json.encode()).hexdigest()
        # 2. Construct the string to sign
        string_to_sign = f"POST:{self.va}:{body_sha256_hash}:{self.api_key}"
        # 3. Generate HMAC-SHA256 signature
        signature = hmac.new(self.api_key.encode(), string_to_sign.encode(), hashlib.sha256).hexdigest()
        return signature

    async def create_payment_link(self, subscription: Subscription, user: Users) -> tuple[str, str]:
        """
        (Placeholder) Creates a payment link with iPaymu.
        In a real scenario, this would make an HTTP request to iPaymu's API.
        """
        # 1. Prepare payload for iPaymu
        payload = {
            "product": [subscription.plan.name],
            "qty": [1],
            "price": [subscription.plan.price],
            "returnUrl": f"{settings.APP_BASE_URL}/payment-success",
            "notifyUrl": f"{settings.APP_BASE_URL}/api/v1/webhooks/ipaymu-notify",
            "referenceId": str(subscription.id),
            "buyerName": user.name,
            "buyerEmail": user.email,
        }

        # 2. Create signature
        signature = self._create_signature(payload)
        
        # 3. Generate timestamp
        timestamp = datetime.today().strftime('%Y%m%d%H%M%S')
        
        # Log payload, signature, and timestamp for debugging
        print(f"Payload to iPaymu: {payload}")
        print(f"Signature: {signature}")
        print(f"Timestamp: {timestamp}")

        # 4. Make actual API call to iPaymu
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.payment_url,
                    headers={
                        "signature": signature,
                        "va": self.va,
                        "apiKey": self.api_key, 
                        "Content-Type": "application/json",
                        "timestamp": timestamp
                    },
                    json=payload
                )
                response.raise_for_status() 
                response_data = response.json()

                # Check if the response status is successful and data is well-formed
                if response_data.get("Status") == 200:
                    data = response_data.get("Data")
                    # Check if 'Data' is a dictionary and contains 'Url' and 'SessionID' (instead of TransactionId)
                    if data and isinstance(data, dict) and "Url" in data and "SessionID" in data:
                        payment_url = data["Url"]
                        trx_id = data["SessionID"] # Use SessionID as the transaction identifier
                        print(f"--- Received real iPaymu URL: {payment_url} ---")
                        return payment_url, trx_id
                    else:
                        # Handle cases where Status is 200 but Data is missing or malformed
                        print(f"iPaymu API returned Status 200 but malformed Data: {response_data}")
                        raise HTTPException(
                            status_code=500,
                            detail=f"iPaymu API returned a success status but malformed data. Response: {response_data}"
                        )
                else:
                    # This block handles non-200 statuses
                    error_message = response_data.get('Message', 'Unknown iPaymu error')
                    print(f"iPaymu API Error (Status: {response_data.get('Status')}): {error_message}")
                    raise HTTPException(
                        status_code=500,
                        detail=f"Failed to create payment link: {error_message}"
                    )
        except httpx.HTTPStatusError as e:
            print(f"HTTP error creating iPaymu payment link: {e.response.text}")
            raise HTTPException(
                status_code=500,
                detail=f"HTTP error with iPaymu API: {e.response.text}"
            )
        except httpx.RequestError as e:
            print(f"Network error creating iPaymu payment link: {e}")
            raise HTTPException(
                status_code=500,
                detail=f"Network error connecting to iPaymu API: {e}"
            )
        except Exception as e:
            print(f"Unexpected error creating iPaymu payment link: {e}")
            raise HTTPException(
                status_code=500,
                detail=f"An unexpected error occurred: {e}"
            )


    async def verify_webhook_signature(self, request: Request) -> bool:
        """
        (Placeholder) Verifies the incoming webhook signature from iPaymu.
        """
        print("--- Verifying iPaymu Webhook Signature ---")
        # In a real app, you would get the signature from the request headers
        # and the body to recalculate and compare.
        # This is a placeholder and assumes the request is valid.
        # A real implementation would be much more robust.
        
        # try:
        #     signature = request.headers.get('signature')
        #     body = await request.json()
        #     recalculated_signature = self._create_signature(body)
        #     if signature != recalculated_signature:
        #         print("Webhook signature mismatch!")
        #         return False
        # except Exception as e:
        #     print(f"Error verifying webhook signature: {e}")
        #     return False

        print("--- Webhook signature is valid (simulated) ---")
        return True

ipaymu_service = IPaymuService()
